# 4834_숫자카드

* **문제조건**

  * 0에서 9까지 숫자가 적힌 N장의 카드가 주어진다.

  * 가장 많은 카드에 적힌 숫자와 카드가 몇 장인지 출력하는 프로그램을 만드시오. 

    카드 장수가 같을 때는 **적힌 숫자가 큰 쪽을 출력**한다.

* **Input**

  * 첫 줄에 테스트 케이스 개수 T가 주어진다. ( 1 ≤ T ≤ 50 )

  * 다음 줄부터 테스트케이스의 첫 줄에 카드 장수 N이 주어진다. ( 5 ≤ N ≤ 100 )

  * 다음 줄에 N개의 숫자 ai가 여백없이 주어진다. (0으로 시작할 수도 있다.) ( 0 ≤ ai ≤ 9 ) 

  ```
  3
  5
  49679
  5
  08271
  10
  7797946543
  ```

* **Output**

  * 각 줄마다 "#T" (T는 테스트 케이스 번호)를 출력한 뒤, 가장 많은 카드의 숫자와 장 수를 차례로 출력한다.

  ```
  #1 9 2
  #2 8 1
  #3 7 3
  ```

---

* **Idea**
  1. 카운팅 정렬 할 때처럼 0~9까지 0으로 채워진 배열을 하나 만들고입력받은 값들에 해당하면 한개씩 올려주기
  2. 올려준 다음에 그 해당 인덱스와 값을 출력하기

---

* **Code**

  ```python
  import sys
  sys.stdin = open("input.txt")
  
  T = int(input())
  
  for tc in range(1, T+1):
      # 카드 장 수
      # 한줄로 들어오는 숫자를 따로따로 분리
      # [4, 9, 6, 7, 9] 이런식
      N = int(input())
      numbers = list(map(int, input()))
  
      # 0~9(10개)까지니까 각 숫자의 갯수를 담아줄 cnt리스트 만듬
      cnt = [0] *10
      # 자기 자신에 해당하는 cnt의 idx값에 들어가서 +1 해주기
      for number in numbers:
          cnt[number] += 1
      # [0, 0, 0, 0, 1, 0, 1, 1, 0, 2]
  
      # 제일 큰 값을 cnt의 0번째로 지정하고
      max_cnt_val = cnt[0]
      # 위에서 0번째를 max_cnt_val정했으니까 1번째 인덱스부터 max_cnt_val와 값 비교
      for i in range(1, 10):
          # 카드 장수가 같은 경우도 봐줘야하니까 = 넣어야하고
          if cnt[i] >= max_cnt_val:
              # 카드 장수가 같으면 그 해당 인덱스 값을 res라는 새로운 변수에 저장
              res = i
              max_cnt_val = cnt[i]
      print("#{} {} {}".format(tc, res , max_cnt_val))
  
  
  ```

---

* **review**

  *  if cnt[i] >= max_cnt_val:

    이 부분에서 그냥 평소에 하던 것 처럼 max 값을 찾으려고 `>`이런식으로 써서 진행을 했더니 두번째 테스트 케이스에서 `#2 0 1`라는 결과를 받았다. 그래서 두번째 테스트 케이스의 입력값을 살펴본 결과

    ```
    5
    08271
    ```

    이렇게 들어온다. cnt출력해보면 [1, 1, 1, 0, 0, 0, 0, 1, 1, 0] 임을 알 수 있다. 

    최대값이 1인 경우이다. 따라서 조건식에 `>` 만 넣어줄 경우 처음 1만 봐주고 뒤를 넘어가지 않기 때문에 인덱스도 0에서 머물러 있기 때문에 뒤에까지 조건식을 모두 돌게 만들기 위해서는 `>=`로 조건식을 바꿔줘야한다.

    ***평소 하던대로 그냥 짜지말고 생각하면서 조건식 짜기 ㅠㅠ***

